'use client'

import { useEffect, useState, useMemo } from 'react'
import { useSearchParams } from 'next/navigation'
import { createClient } from '@/lib/supabase/client'
import { useAppSelector, useAppDispatch } from '@/lib/store/hooks'
import { setPurchases, addPurchase, updatePurchase, deletePurchase } from '@/lib/store/slices/purchasesSlice'
import { setEmployees } from '@/lib/store/slices/employeesSlice'
import { setCards } from '@/lib/store/slices/cardsSlice'
import { setCategories } from '@/lib/store/slices/categoriesSlice'
import { Button } from '@/components/ui/button'
import { Input } from '@/components/ui/input'
import { Label } from '@/components/ui/label'
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from '@/components/ui/select'
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from '@/components/ui/table'
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogHeader,
  DialogTitle,
  DialogTrigger,
  DialogFooter,
} from '@/components/ui/dialog'
import { Badge } from '@/components/ui/badge'
import { Plus, Pencil, Trash2, Check, X, CheckSquare, UserPlus, Download } from 'lucide-react'
import { toast } from 'sonner'
import { Database } from '@/lib/types/database.types'
import { format } from 'date-fns'
import { PurchaseFilters, type PurchaseFilterValues } from '@/components/purchases/PurchaseFilters'

type Purchase = Database['public']['Tables']['purchases']['Row']
type PurchaseInsert = Database['public']['Tables']['purchases']['Insert']

export default function PurchasesPage() {
  const { user } = useAppSelector((state) => state.auth)
  const { purchases } = useAppSelector((state) => state.purchases)
  const { employees } = useAppSelector((state) => state.employees)
  const { cards } = useAppSelector((state) => state.cards)
  const { categories } = useAppSelector((state) => state.categories)
  const dispatch = useAppDispatch()
  const searchParams = useSearchParams()
  const supabase = createClient()

  const [isDialogOpen, setIsDialogOpen] = useState(false)
  const [isEditing, setIsEditing] = useState(false)
  const [currentPurchase, setCurrentPurchase] = useState<Purchase | null>(null)

  // Selection mode state
  const [selectionMode, setSelectionMode] = useState(false)
  const [selectedPurchases, setSelectedPurchases] = useState<Set<string>>(new Set())
  const [autoSelectFromShift, setAutoSelectFromShift] = useState(false)

  // Bulk assign employee dialog
  const [bulkAssignDialogOpen, setBulkAssignDialogOpen] = useState(false)
  const [bulkAssignEmployeeId, setBulkAssignEmployeeId] = useState('')

  const [formData, setFormData] = useState({
    purchase_date: '',
    merchant: '',
    amount: '',
    employee_id: '',
    card_id: '',
    category_id: '',
    description: '',
  })

  // Filter state
  const [filters, setFilters] = useState<PurchaseFilterValues>({
    startDate: null,
    endDate: null,
    minAmount: null,
    maxAmount: null,
    employeeIds: [],
    cardIds: [],
    source: null,
    reviewedStatus: null,
    searchQuery: '',
  })

  // Apply filters to purchases
  const filteredPurchases = useMemo(() => {
    let filtered = [...purchases]

    // Search query
    if (filters.searchQuery) {
      const query = filters.searchQuery.toLowerCase()
      filtered = filtered.filter(p => 
        p.merchant?.toLowerCase().includes(query) ||
        p.description?.toLowerCase().includes(query)
      )
    }

    // Date range
    if (filters.startDate) {
      filtered = filtered.filter(p => new Date(p.created_at) >= filters.startDate!)
    }
    if (filters.endDate) {
      filtered = filtered.filter(p => new Date(p.created_at) <= filters.endDate!)
    }

    // Amount range
    if (filters.minAmount !== null) {
      filtered = filtered.filter(p => p.amount >= filters.minAmount!)
    }
    if (filters.maxAmount !== null) {
      filtered = filtered.filter(p => p.amount <= filters.maxAmount!)
    }

    // Employee filter
    if (filters.employeeIds.length > 0) {
      filtered = filtered.filter(p => p.employee_id && filters.employeeIds.includes(p.employee_id))
    }

    // Card filter
    if (filters.cardIds.length > 0) {
      filtered = filtered.filter(p => p.card_id && filters.cardIds.includes(p.card_id))
    }

    // Source filter
    if (filters.source !== null) {
      filtered = filtered.filter(p => 
        filters.source === 'email' ? p.raw_email_id !== null : p.raw_email_id === null
      )
    }

    // Reviewed status filter
    if (filters.reviewedStatus !== null) {
      filtered = filtered.filter(p => p.is_reviewed === filters.reviewedStatus)
    }

    return filtered
  }, [purchases, filters])

  // Calculate selection summary
  const selectionSummary = useMemo(() => {
    const selected = filteredPurchases.filter(p => selectedPurchases.has(p.id))
    const total = selected.reduce((sum, p) => sum + p.amount, 0)
    return {
      count: selected.length,
      total: total
    }
  }, [filteredPurchases, selectedPurchases])

  // Debug: log filter results after useMemo completes
  console.log("ðŸ“Š Total purchases:", purchases.length, "Filtered:", filteredPurchases.length, "Active filters:", Object.values(filters).filter(v => v !== null && (Array.isArray(v) ? v.length > 0 : v !== "")).length)

  useEffect(() => {
    if (user) {
      fetchPurchases()
      fetchEmployees()
      fetchCards()
      fetchCategories()
    }
  }, [user])

  // Read URL parameters and apply filters from shift navigation
  useEffect(() => {
    const cardId = searchParams.get('cardId')
    const employeeId = searchParams.get('employeeId')
    const startDate = searchParams.get('startDate')
    const endDate = searchParams.get('endDate')

    if (cardId || employeeId || startDate || endDate) {
      // Enable selection mode
      setSelectionMode(true)
      
      // Set flag to auto-select after filters apply
      setAutoSelectFromShift(true)
      
      setFilters(prev => ({
        ...prev,
        cardIds: cardId ? [cardId] : [],
        employeeIds: employeeId ? [employeeId] : [],
        startDate: startDate ? new Date(startDate) : null,
        endDate: endDate ? new Date(endDate) : null,
      }))
    }
  }, [searchParams])

  // Auto-select all filtered purchases when coming from shift
  useEffect(() => {
    if (autoSelectFromShift && filteredPurchases.length > 0) {
      setSelectedPurchases(new Set(filteredPurchases.map(p => p.id)))
      setAutoSelectFromShift(false) // Only run once
    }
  }, [autoSelectFromShift, filteredPurchases])

  const fetchPurchases = async () => {
    console.log("ðŸ” Fetching purchases for user:", user?.id)
    if (!user) return

    try {
      const { data, error } = await supabase
        .from('purchases')
        .select('*')
        .eq('admin_user_id', user.id)
        .order('created_at', { ascending: false })

      console.log("ðŸ“¦ Purchases fetched:", data?.length, "items", data)
      if (error) throw error
      dispatch(setPurchases(data || []))
    } catch (error: any) {
      console.error('Error fetching purchases:', error)
      toast.error('Failed to load purchases')
    }
  }

  const fetchEmployees = async () => {
    if (!user) return

    try {
      const { data, error } = await supabase
        .from('employees')
        .select('*')
        .eq('admin_user_id', user.id)
        .order('name')

      if (error) throw error
      dispatch(setEmployees(data || []))
    } catch (error: any) {
      console.error('Error fetching employees:', error)
    }
  }

  const fetchCards = async () => {
    if (!user) return

    try {
      const { data, error } = await supabase
        .from('cards')
        .select('*')
        .eq('admin_user_id', user.id)
        .order('last_four')

      if (error) throw error
      dispatch(setCards(data || []))
    } catch (error: any) {
      console.error('Error fetching cards:', error)
    }
  }

  const fetchCategories = async () => {
    if (!user) return

    try {
      const { data, error } = await supabase
        .from('categories')
        .select('*')
        .eq('admin_user_id', user.id)
        .order('name')

      if (error) throw error
      dispatch(setCategories(data || []))
    } catch (error: any) {
      console.error('Error fetching categories:', error)
    }
  }

  const handleOpenDialog = (purchase?: Purchase) => {
    if (purchase) {
      setIsEditing(true)
      setCurrentPurchase(purchase)
      setFormData({
        purchase_date: purchase.purchase_date || '',
        merchant: purchase.merchant || '',
        amount: purchase.amount.toString(),
        employee_id: purchase.employee_id || '',
        card_id: purchase.card_id || '',
        category_id: purchase.category_id || '',
        description: purchase.description || '',
      })
    } else {
      setIsEditing(false)
      setCurrentPurchase(null)
      setFormData({
        purchase_date: '',
        merchant: '',
        amount: '',
        employee_id: '',
        card_id: '',
        category_id: '',
        description: '',
      })
    }
    setIsDialogOpen(true)
  }

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault()

    if (!user) return

    try {
      const purchaseData: any = {
        admin_user_id: user.id,
        purchase_date: formData.purchase_date || new Date().toISOString().split('T')[0],
        merchant: formData.merchant,
        amount: parseFloat(formData.amount),
        employee_id: formData.employee_id || null,
        card_id: formData.card_id || null,
        category_id: formData.category_id || null,
        description: formData.description || null,
      }

      if (isEditing && currentPurchase) {
        const { data, error } = await supabase
          .from('purchases')
          .update(purchaseData)
          .eq('id', currentPurchase.id)
          .select()
          .single()

        if (error) throw error
        dispatch(updatePurchase(data))
        toast.success('Purchase updated successfully')
      } else {
        const { data, error } = await supabase
          .from('purchases')
          .insert([purchaseData])
          .select()
          .single()

        if (error) throw error
        dispatch(addPurchase(data))
        toast.success('Purchase added successfully')
      }

      setIsDialogOpen(false)
    } catch (error: any) {
      console.error('Error saving purchase:', error)
      toast.error('Failed to save purchase')
    }
  }

  const handleDelete = async (id: string) => {
    if (!confirm('Are you sure you want to delete this purchase?')) return

    try {
      const { error } = await supabase
        .from('purchases')
        .delete()
        .eq('id', id)

      if (error) throw error
      dispatch(deletePurchase(id))
      toast.success('Purchase deleted successfully')
    } catch (error: any) {
      console.error('Error deleting purchase:', error)
      toast.error('Failed to delete purchase')
    }
  }

  const toggleReviewed = async (purchase: Purchase) => {
    try {
      const { data, error } = await supabase
        .from('purchases')
        .update({ is_reviewed: !purchase.is_reviewed })
        .eq('id', purchase.id)
        .select()
        .single()

      if (error) throw error
      dispatch(updatePurchase(data))
      toast.success(data.is_reviewed ? 'Marked as reviewed' : 'Marked as unreviewed')
    } catch (error: any) {
      console.error('Error toggling reviewed:', error)
      toast.error('Failed to update status')
    }
  }

  // Bulk operations
  const handleBulkMarkReviewed = async () => {
    if (selectedPurchases.size === 0) return

    try {
      const selectedIds = Array.from(selectedPurchases)
      
      const { data, error } = await supabase
        .from('purchases')
        .update({ is_reviewed: true })
        .in('id', selectedIds)
        .select()

      if (error) throw error
      
      // Update Redux store
      data.forEach(purchase => {
        dispatch(updatePurchase(purchase))
      })

      toast.success(`Marked ${selectedIds.length} purchase${selectedIds.length === 1 ? '' : 's'} as reviewed`)
      setSelectedPurchases(new Set()) // Clear selection
    } catch (error: any) {
      console.error('Error bulk marking as reviewed:', error)
      toast.error('Failed to mark purchases as reviewed')
    }
  }

  const handleBulkAssignEmployee = async () => {
    if (!bulkAssignEmployeeId || selectedPurchases.size === 0) {
      toast.error('Please select an employee')
      return
    }

    try {
      const selectedIds = Array.from(selectedPurchases)
      
      const { data, error } = await supabase
        .from('purchases')
        .update({ employee_id: bulkAssignEmployeeId })
        .in('id', selectedIds)
        .select()

      if (error) throw error
      
      // Update Redux store
      data.forEach(purchase => {
        dispatch(updatePurchase(purchase))
      })

      const employeeName = employees.find(e => e.id === bulkAssignEmployeeId)?.name || 'employee'
      toast.success(`Assigned ${selectedIds.length} purchase${selectedIds.length === 1 ? '' : 's'} to ${employeeName}`)
      
      setBulkAssignDialogOpen(false)
      setBulkAssignEmployeeId('')
      setSelectedPurchases(new Set()) // Clear selection
    } catch (error: any) {
      console.error('Error bulk assigning employee:', error)
      toast.error('Failed to assign employee')
    }
  }

  // Selection mode functions
  const toggleSelectionMode = () => {
    setSelectionMode(!selectionMode)
    if (selectionMode) {
      // Clear selections when exiting selection mode
      setSelectedPurchases(new Set())
    }
  }

  const togglePurchaseSelection = (purchaseId: string) => {
    const newSelected = new Set(selectedPurchases)
    if (newSelected.has(purchaseId)) {
      newSelected.delete(purchaseId)
    } else {
      newSelected.add(purchaseId)
    }
    setSelectedPurchases(newSelected)
  }

  const toggleSelectAll = () => {
    if (selectedPurchases.size === filteredPurchases.length) {
      // Deselect all
      setSelectedPurchases(new Set())
    } else {
      // Select all filtered
      setSelectedPurchases(new Set(filteredPurchases.map(p => p.id)))
    }
  }

  const clearSelection = () => {
    setSelectedPurchases(new Set())
  }

  const getEmployeeName = (employeeId: string | null) => {
    if (!employeeId) return 'N/A'
    return employees.find(e => e.id === employeeId)?.name || 'Unknown'
  }

  const getCardDisplay = (cardId: string | null) => {
    if (!cardId) return 'N/A'
    const card = cards.find(c => c.id === cardId)
    return card ? `**** ${card.last_four}` : 'Unknown'
  }

  const getCategoryColor = (categoryId: string | null) => {
    if (!categoryId) return '#6366f1'
    return categories.find(c => c.id === categoryId)?.color || '#6366f1'
  }

  return (
    <div>
      <div className="mb-6 flex flex-col sm:flex-row items-start sm:items-center justify-between gap-4">
        <div>
          <h1 className="text-2xl font-bold text-gray-900">Purchases</h1>
          <p className="mt-1 text-sm text-gray-600">
            View and manage all purchase transactions
          </p>
        </div>
        <div className="flex gap-2 w-full sm:w-auto">
          <Button
            variant={selectionMode ? "outline" : "secondary"}
            onClick={toggleSelectionMode}
            className="flex-1 sm:flex-none"
          >
            <CheckSquare className="mr-2 h-4 w-4" />
            {selectionMode ? 'Cancel Selection' : 'Operations'}
          </Button>
          <Dialog open={isDialogOpen} onOpenChange={setIsDialogOpen}>
            <DialogTrigger asChild>
              <Button onClick={() => handleOpenDialog()} className="flex-1 sm:flex-none">
                <Plus className="mr-2 h-4 w-4" />
                Add Purchase
              </Button>
            </DialogTrigger>
            <DialogContent className="max-w-2xl">
              <DialogHeader>
                <DialogTitle>
                  {isEditing ? 'Edit Purchase' : 'Add Manual Purchase'}
                </DialogTitle>
                <DialogDescription>
                  {isEditing
                    ? 'Update purchase details'
                    : 'Manually add a purchase transaction'}
                </DialogDescription>
              </DialogHeader>
              <form onSubmit={handleSubmit}>
                <div className="grid gap-4 py-4 md:grid-cols-2">
                  <div className="space-y-2">
                    <Label htmlFor="amount">Amount (CAD) *</Label>
                    <Input
                      id="amount"
                      type="number"
                      step="0.01"
                      placeholder="0.00"
                      value={formData.amount}
                      onChange={(e) =>
                        setFormData({ ...formData, amount: e.target.value })
                      }
                      required
                    />
                  </div>
                  <div className="space-y-2">
                    <Label htmlFor="merchant">Merchant *</Label>
                    <Input
                      id="merchant"
                      placeholder="Enter merchant name"
                      value={formData.merchant}
                      onChange={(e) =>
                        setFormData({ ...formData, merchant: e.target.value })
                      }
                      required
                    />
                  </div>
                  <div className="space-y-2">
                    <Label htmlFor="purchase_date">Purchase Date</Label>
                    <Input
                      id="purchase_date"
                      type="date"
                      value={formData.purchase_date}
                      onChange={(e) =>
                        setFormData({ ...formData, purchase_date: e.target.value })
                      }
                    />
                  </div>
                  <div className="space-y-2">
                    <Label htmlFor="employee_id">Employee</Label>
                    <Select
                      value={formData.employee_id}
                      onValueChange={(value) =>
                        setFormData({ ...formData, employee_id: value })
                      }
                    >
                      <SelectTrigger>
                        <SelectValue placeholder="Select employee" />
                      </SelectTrigger>
                      <SelectContent>
                        <SelectItem value="">None</SelectItem>
                        {employees.map((employee) => (
                          <SelectItem key={employee.id} value={employee.id}>
                            {employee.name}
                          </SelectItem>
                        ))}
                      </SelectContent>
                    </Select>
                  </div>
                  <div className="space-y-2">
                    <Label htmlFor="card_id">Card</Label>
                    <Select
                      value={formData.card_id}
                      onValueChange={(value) =>
                        setFormData({ ...formData, card_id: value })
                      }
                    >
                      <SelectTrigger>
                        <SelectValue placeholder="Select card" />
                      </SelectTrigger>
                      <SelectContent>
                        <SelectItem value="">None</SelectItem>
                        {cards.map((card) => (
                          <SelectItem key={card.id} value={card.id}>
                            **** {card.last_four}
                          </SelectItem>
                        ))}
                      </SelectContent>
                    </Select>
                  </div>
                  <div className="space-y-2">
                    <Label htmlFor="category_id">Category</Label>
                    <Select
                      value={formData.category_id}
                      onValueChange={(value) =>
                        setFormData({ ...formData, category_id: value })
                      }
                    >
                      <SelectTrigger>
                        <SelectValue placeholder="Select category" />
                      </SelectTrigger>
                      <SelectContent>
                        <SelectItem value="">None</SelectItem>
                        {categories.map((category) => (
                          <SelectItem key={category.id} value={category.id}>
                            {category.name}
                          </SelectItem>
                        ))}
                      </SelectContent>
                    </Select>
                  </div>
                  <div className="col-span-2 space-y-2">
                    <Label htmlFor="description">Description</Label>
                    <Input
                      id="description"
                      placeholder="Optional description"
                      value={formData.description}
                      onChange={(e) =>
                        setFormData({ ...formData, description: e.target.value })
                      }
                    />
                  </div>
                </div>
                <DialogFooter>
                  <Button type="submit">
                    {isEditing ? 'Update' : 'Add'} Purchase
                  </Button>
                </DialogFooter>
              </form>
            </DialogContent>
          </Dialog>
        </div>
      </div>

      {/* Advanced Filters */}
      <div className="mb-6">
        <PurchaseFilters
          filters={filters}
          onFilterChange={setFilters}
          employees={employees}
          cards={cards}
        />
      </div>

      {/* Selection Summary with Bulk Actions */}
      {selectionMode && selectedPurchases.size > 0 && (
        <div className="mb-4 rounded-lg border bg-blue-50 border-blue-200 p-4">
          <div className="flex flex-col gap-3">
            <div className="flex flex-col sm:flex-row items-start sm:items-center justify-between gap-2">
              <div className="flex items-center gap-4">
                <span className="font-semibold text-blue-900">
                  {selectionSummary.count} {selectionSummary.count === 1 ? 'purchase' : 'purchases'} selected
                </span>
                <span className="text-blue-700">
                  Total: ${selectionSummary.total.toFixed(2)}
                </span>
              </div>
              <Button
                variant="outline"
                size="sm"
                onClick={clearSelection}
                className="w-full sm:w-auto"
              >
                Clear Selection
              </Button>
            </div>
            
            {/* Bulk Action Buttons */}
            <div className="flex flex-col sm:flex-row gap-2">
              <Button
                variant="default"
                size="sm"
                onClick={handleBulkMarkReviewed}
                className="w-full sm:w-auto"
              >
                <Check className="mr-2 h-4 w-4" />
                Mark as Reviewed
              </Button>
              
              <Dialog open={bulkAssignDialogOpen} onOpenChange={setBulkAssignDialogOpen}>
                <DialogTrigger asChild>
                  <Button
                    variant="default"
                    size="sm"
                    className="w-full sm:w-auto"
                  >
                    <UserPlus className="mr-2 h-4 w-4" />
                    Assign to Employee
                  </Button>
                </DialogTrigger>
                <DialogContent>
                  <DialogHeader>
                    <DialogTitle>Assign to Employee</DialogTitle>
                    <DialogDescription>
                      Assign {selectionSummary.count} selected purchase{selectionSummary.count === 1 ? '' : 's'} to an employee
                    </DialogDescription>
                  </DialogHeader>
                  <div className="space-y-4 py-4">
                    <div className="space-y-2">
                      <Label htmlFor="bulk-employee">Select Employee</Label>
                      <Select
                        value={bulkAssignEmployeeId}
                        onValueChange={setBulkAssignEmployeeId}
                      >
                        <SelectTrigger id="bulk-employee">
                          <SelectValue placeholder="Select employee" />
                        </SelectTrigger>
                        <SelectContent>
                          {employees.map((employee) => (
                            <SelectItem key={employee.id} value={employee.id}>
                              {employee.name}
                            </SelectItem>
                          ))}
                        </SelectContent>
                      </Select>
                    </div>
                  </div>
                  <DialogFooter>
                    <Button variant="outline" onClick={() => setBulkAssignDialogOpen(false)}>
                      Cancel
                    </Button>
                    <Button onClick={handleBulkAssignEmployee}>
                      Assign
                    </Button>
                  </DialogFooter>
                </DialogContent>
              </Dialog>
            </div>
          </div>
        </div>
      )}

      {/* Purchases Table */}
      <div className="rounded-lg border bg-white">
        <Table>
          <TableHeader>
            <TableRow>
              {selectionMode && (
                <TableHead className="w-12">
                  <input
                    type="checkbox"
                    checked={filteredPurchases.length > 0 && selectedPurchases.size === filteredPurchases.length}
                    onChange={toggleSelectAll}
                    className="h-4 w-4 rounded border-gray-300"
                  />
                </TableHead>
              )}
              <TableHead>Date & Time</TableHead>
              <TableHead>Merchant</TableHead>
              <TableHead>Amount</TableHead>
              <TableHead>Employee</TableHead>
              <TableHead>Card</TableHead>
              <TableHead>Source</TableHead>
              <TableHead>Reviewed</TableHead>
              <TableHead className="text-right">Actions</TableHead>
            </TableRow>
          </TableHeader>
          <TableBody>
            {filteredPurchases.length === 0 ? (
              <TableRow>
                <TableCell colSpan={selectionMode ? 9 : 8} className="text-center text-gray-500">
                  {purchases.length === 0 ? 'No purchases found' : 'No purchases match your filters'}
                </TableCell>
              </TableRow>
            ) : (
              filteredPurchases.map((purchase) => (
                <TableRow key={purchase.id}>
                  {selectionMode && (
                    <TableCell>
                      <input
                        type="checkbox"
                        checked={selectedPurchases.has(purchase.id)}
                        onChange={() => togglePurchaseSelection(purchase.id)}
                        className="h-4 w-4 rounded border-gray-300"
                      />
                    </TableCell>
                  )}
                  <TableCell>
                    {format(new Date(purchase.created_at), 'MMM dd, HH:mm')}
                  </TableCell>
                  <TableCell>
                    <div>
                      <div className="font-medium">{purchase.merchant}</div>
                      {purchase.description && (
                        <div className="text-xs text-gray-500">
                          {purchase.description}
                        </div>
                      )}
                    </div>
                  </TableCell>
                  <TableCell className="font-semibold">
                    ${purchase.amount.toFixed(2)}
                  </TableCell>
                  <TableCell>{getEmployeeName(purchase.employee_id)}</TableCell>
                  <TableCell>{getCardDisplay(purchase.card_id)}</TableCell>
                  <TableCell>
                    <Badge variant={purchase.raw_email_id ? 'default' : 'secondary'}>
                      {purchase.raw_email_id ? 'Email' : 'Manual'}
                    </Badge>
                  </TableCell>
                  <TableCell>
                    <Button
                      variant="ghost"
                      size="sm"
                      onClick={() => toggleReviewed(purchase)}
                      className={
                        purchase.is_reviewed
                          ? 'text-green-600 hover:text-green-700'
                          : 'text-gray-400 hover:text-gray-500'
                      }
                    >
                      {purchase.is_reviewed ? (
                        <Check className="h-5 w-5" />
                      ) : (
                        <X className="h-5 w-5" />
                      )}
                    </Button>
                  </TableCell>
                  <TableCell className="text-right">
                    <div className="flex justify-end gap-2">
                      <Button
                        variant="ghost"
                        size="sm"
                        onClick={() => handleOpenDialog(purchase)}
                      >
                        <Pencil className="h-4 w-4" />
                      </Button>
                      <Button
                        variant="ghost"
                        size="sm"
                        onClick={() => handleDelete(purchase.id)}
                      >
                        <Trash2 className="h-4 w-4 text-red-600" />
                      </Button>
                    </div>
                  </TableCell>
                </TableRow>
              ))
            )}
          </TableBody>
        </Table>
      </div>

      {/* Filter Summary */}
      {filteredPurchases.length !== purchases.length && (
        <div className="mt-4 text-sm text-gray-600">
          Showing {filteredPurchases.length} of {purchases.length} purchases
        </div>
      )}
    </div>
  )
}
